// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_common_2fenums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_2fenums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2fenums_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_2fenums_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace common {

enum OrderStatus : int {
  ORDER_STATUS_DEFAULT = 0,
  ENTERED = 1,
  EXECUTING = 2,
  COMPLETED = 3,
  REJECTED = 4,
  CANCELED = 5,
  ABORTED = 6,
  UPDATED = 7,
  OrderStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OrderStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OrderStatus_IsValid(int value);
constexpr OrderStatus OrderStatus_MIN = ORDER_STATUS_DEFAULT;
constexpr OrderStatus OrderStatus_MAX = UPDATED;
constexpr int OrderStatus_ARRAYSIZE = OrderStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderStatus_descriptor();
template<typename T>
inline const std::string& OrderStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OrderStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OrderStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OrderStatus_descriptor(), enum_t_value);
}
inline bool OrderStatus_Parse(
    const std::string& name, OrderStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderStatus>(
    OrderStatus_descriptor(), name, value);
}
enum OrderType : int {
  ORDER_TYPE_DEFAULT = 0,
  MOVE = 1,
  DELIVER = 2,
  RECEIVE = 3,
  CHARGE = 4,
  MAINTENANCE = 5,
  PARK = 6,
  OrderType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OrderType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OrderType_IsValid(int value);
constexpr OrderType OrderType_MIN = ORDER_TYPE_DEFAULT;
constexpr OrderType OrderType_MAX = PARK;
constexpr int OrderType_ARRAYSIZE = OrderType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderType_descriptor();
template<typename T>
inline const std::string& OrderType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OrderType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OrderType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OrderType_descriptor(), enum_t_value);
}
inline bool OrderType_Parse(
    const std::string& name, OrderType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderType>(
    OrderType_descriptor(), name, value);
}
enum BusinessType : int {
  BUSINESS_TYPE_DEFAULT = 0,
  LOAD = 1,
  DSCH = 2,
  YARD_MOVE = 3,
  MANUAL_MOVE = 4,
  BT_PARK = 5,
  BT_CHARGE = 6,
  XRAY = 7,
  BusinessType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BusinessType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BusinessType_IsValid(int value);
constexpr BusinessType BusinessType_MIN = BUSINESS_TYPE_DEFAULT;
constexpr BusinessType BusinessType_MAX = XRAY;
constexpr int BusinessType_ARRAYSIZE = BusinessType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BusinessType_descriptor();
template<typename T>
inline const std::string& BusinessType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BusinessType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BusinessType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BusinessType_descriptor(), enum_t_value);
}
inline bool BusinessType_Parse(
    const std::string& name, BusinessType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BusinessType>(
    BusinessType_descriptor(), name, value);
}
enum TechnicalStatus : int {
  TECH_STATUS_DEFAULT = 0,
  GREEN = 1,
  YELLOW = 2,
  ORANGE = 3,
  RED = 4,
  TechnicalStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TechnicalStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TechnicalStatus_IsValid(int value);
constexpr TechnicalStatus TechnicalStatus_MIN = TECH_STATUS_DEFAULT;
constexpr TechnicalStatus TechnicalStatus_MAX = RED;
constexpr int TechnicalStatus_ARRAYSIZE = TechnicalStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TechnicalStatus_descriptor();
template<typename T>
inline const std::string& TechnicalStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TechnicalStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TechnicalStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TechnicalStatus_descriptor(), enum_t_value);
}
inline bool TechnicalStatus_Parse(
    const std::string& name, TechnicalStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TechnicalStatus>(
    TechnicalStatus_descriptor(), name, value);
}
enum MotionStatus : int {
  MOTION_STATUS_DEFAULT = 0,
  MOTION = 1,
  STATIC = 2,
  MotionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MotionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MotionStatus_IsValid(int value);
constexpr MotionStatus MotionStatus_MIN = MOTION_STATUS_DEFAULT;
constexpr MotionStatus MotionStatus_MAX = STATIC;
constexpr int MotionStatus_ARRAYSIZE = MotionStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionStatus_descriptor();
template<typename T>
inline const std::string& MotionStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MotionStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MotionStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MotionStatus_descriptor(), enum_t_value);
}
inline bool MotionStatus_Parse(
    const std::string& name, MotionStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MotionStatus>(
    MotionStatus_descriptor(), name, value);
}
enum WorkCycleDirection : int {
  WORK_CYCLE_DIRECTION_DEFAULT = 0,
  CLOCKWISE = 1,
  ANTI_CLOCKWISE = 2,
  WorkCycleDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WorkCycleDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WorkCycleDirection_IsValid(int value);
constexpr WorkCycleDirection WorkCycleDirection_MIN = WORK_CYCLE_DIRECTION_DEFAULT;
constexpr WorkCycleDirection WorkCycleDirection_MAX = ANTI_CLOCKWISE;
constexpr int WorkCycleDirection_ARRAYSIZE = WorkCycleDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkCycleDirection_descriptor();
template<typename T>
inline const std::string& WorkCycleDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkCycleDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkCycleDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkCycleDirection_descriptor(), enum_t_value);
}
inline bool WorkCycleDirection_Parse(
    const std::string& name, WorkCycleDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkCycleDirection>(
    WorkCycleDirection_descriptor(), name, value);
}
enum VesselDirection : int {
  VESSEL_DIRECTION_DEFAULT = 0,
  RIGHT = 1,
  LEFT = 2,
  VesselDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  VesselDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool VesselDirection_IsValid(int value);
constexpr VesselDirection VesselDirection_MIN = VESSEL_DIRECTION_DEFAULT;
constexpr VesselDirection VesselDirection_MAX = LEFT;
constexpr int VesselDirection_ARRAYSIZE = VesselDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VesselDirection_descriptor();
template<typename T>
inline const std::string& VesselDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VesselDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VesselDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VesselDirection_descriptor(), enum_t_value);
}
inline bool VesselDirection_Parse(
    const std::string& name, VesselDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VesselDirection>(
    VesselDirection_descriptor(), name, value);
}
enum Gear : int {
  P = 0,
  R = 1,
  N = 2,
  D = 3,
  Gear_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Gear_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Gear_IsValid(int value);
constexpr Gear Gear_MIN = P;
constexpr Gear Gear_MAX = D;
constexpr int Gear_ARRAYSIZE = Gear_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Gear_descriptor();
template<typename T>
inline const std::string& Gear_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Gear>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Gear_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Gear_descriptor(), enum_t_value);
}
inline bool Gear_Parse(
    const std::string& name, Gear* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Gear>(
    Gear_descriptor(), name, value);
}
enum OperationalStatus : int {
  OPERATION_STATUS_DEFAULT = 0,
  OFFLINE = 1,
  AUTOMATIC = 2,
  REMOTECONTROL = 3,
  MANUAL = 4,
  RECHARGE = 5,
  MAINTANANCE = 6,
  FAULT = 7,
  AUTOSTANDBY = 8,
  TEST = 9,
  OperationalStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OperationalStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OperationalStatus_IsValid(int value);
constexpr OperationalStatus OperationalStatus_MIN = OPERATION_STATUS_DEFAULT;
constexpr OperationalStatus OperationalStatus_MAX = TEST;
constexpr int OperationalStatus_ARRAYSIZE = OperationalStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OperationalStatus_descriptor();
template<typename T>
inline const std::string& OperationalStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OperationalStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OperationalStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OperationalStatus_descriptor(), enum_t_value);
}
inline bool OperationalStatus_Parse(
    const std::string& name, OperationalStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OperationalStatus>(
    OperationalStatus_descriptor(), name, value);
}
enum TurnLight : int {
  TRUNLIGHT_DEFAULT = 0,
  LEFT_DIRECTION = 1,
  RIGHT_DIRECTION = 2,
  TurnLight_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TurnLight_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TurnLight_IsValid(int value);
constexpr TurnLight TurnLight_MIN = TRUNLIGHT_DEFAULT;
constexpr TurnLight TurnLight_MAX = RIGHT_DIRECTION;
constexpr int TurnLight_ARRAYSIZE = TurnLight_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TurnLight_descriptor();
template<typename T>
inline const std::string& TurnLight_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TurnLight>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TurnLight_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TurnLight_descriptor(), enum_t_value);
}
inline bool TurnLight_Parse(
    const std::string& name, TurnLight* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TurnLight>(
    TurnLight_descriptor(), name, value);
}
enum StateFlow : int {
  IDLE = 0,
  EXECUTE_RUNNING = 1,
  EXECUTE_PNDARRIVED = 2,
  EXECUTE_AUTOALIGNING = 3,
  EXECUTE_ARRIVED = 4,
  STOPPING = 5,
  STOP_STOPPED = 6,
  ALIGN_ALIGNING = 7,
  ALIGN_ALIGNED = 8,
  WORKING = 9,
  SLEEP = 10,
  CHARGER_CHARGING = 11,
  CHARGER_CLOSEHV = 12,
  STATE_FLOW_OFFLINE = 99,
  StateFlow_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StateFlow_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StateFlow_IsValid(int value);
constexpr StateFlow StateFlow_MIN = IDLE;
constexpr StateFlow StateFlow_MAX = STATE_FLOW_OFFLINE;
constexpr int StateFlow_ARRAYSIZE = StateFlow_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StateFlow_descriptor();
template<typename T>
inline const std::string& StateFlow_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StateFlow>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StateFlow_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StateFlow_descriptor(), enum_t_value);
}
inline bool StateFlow_Parse(
    const std::string& name, StateFlow* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StateFlow>(
    StateFlow_descriptor(), name, value);
}
enum ContainerPos : int {
  CONTAINER_POS_DEFAULT = 0,
  CON_POS_FRONT = 1,
  CON_POS_MID = 2,
  CON_POS_REAR = 3,
  ContainerPos_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ContainerPos_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ContainerPos_IsValid(int value);
constexpr ContainerPos ContainerPos_MIN = CONTAINER_POS_DEFAULT;
constexpr ContainerPos ContainerPos_MAX = CON_POS_REAR;
constexpr int ContainerPos_ARRAYSIZE = ContainerPos_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContainerPos_descriptor();
template<typename T>
inline const std::string& ContainerPos_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContainerPos>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContainerPos_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContainerPos_descriptor(), enum_t_value);
}
inline bool ContainerPos_Parse(
    const std::string& name, ContainerPos* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContainerPos>(
    ContainerPos_descriptor(), name, value);
}
enum TaskType : int {
  TASK_TYPE_DEFAULT = 0,
  EMPTY_TO_QC = 1,
  FULL_TO_QC = 2,
  EMPTY_TO_YC = 3,
  FULL_TO_YC = 4,
  EMPTY_TO_ECY = 5,
  FULL_TO_ECY = 6,
  TO_BUFFER = 7,
  TO_LOCK_AREA = 8,
  EMPTY_TO_INTERACTION = 9,
  FULL_TO_INTERACTION = 10,
  TRUCK_POWER = 11,
  TaskType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaskType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaskType_IsValid(int value);
constexpr TaskType TaskType_MIN = TASK_TYPE_DEFAULT;
constexpr TaskType TaskType_MAX = TRUCK_POWER;
constexpr int TaskType_ARRAYSIZE = TaskType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskType_descriptor();
template<typename T>
inline const std::string& TaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskType_descriptor(), enum_t_value);
}
inline bool TaskType_Parse(
    const std::string& name, TaskType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskType>(
    TaskType_descriptor(), name, value);
}
enum TaskMode : int {
  TASK_MODE_DEFAULT = 0,
  AUTO = 1,
  GUI = 2,
  ACTIVE_GUIDE = 3,
  PASSIVE_GUIDE = 4,
  TaskMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaskMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaskMode_IsValid(int value);
constexpr TaskMode TaskMode_MIN = TASK_MODE_DEFAULT;
constexpr TaskMode TaskMode_MAX = PASSIVE_GUIDE;
constexpr int TaskMode_ARRAYSIZE = TaskMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskMode_descriptor();
template<typename T>
inline const std::string& TaskMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskMode_descriptor(), enum_t_value);
}
inline bool TaskMode_Parse(
    const std::string& name, TaskMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskMode>(
    TaskMode_descriptor(), name, value);
}
enum SteeringMode : int {
  STEERING_MODE_DEFAULT = 0,
  CRAB_WALK = 1,
  FRONT_HALF8 = 2,
  REAR_HALF8 = 3,
  SteeringMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SteeringMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SteeringMode_IsValid(int value);
constexpr SteeringMode SteeringMode_MIN = STEERING_MODE_DEFAULT;
constexpr SteeringMode SteeringMode_MAX = REAR_HALF8;
constexpr int SteeringMode_ARRAYSIZE = SteeringMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SteeringMode_descriptor();
template<typename T>
inline const std::string& SteeringMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SteeringMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SteeringMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SteeringMode_descriptor(), enum_t_value);
}
inline bool SteeringMode_Parse(
    const std::string& name, SteeringMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SteeringMode>(
    SteeringMode_descriptor(), name, value);
}
enum AttendanceState : int {
  ATTENDANCE_STATE_DEFAULT = 0,
  LOGIN = 1,
  LOGOUT = 2,
  AttendanceState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AttendanceState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AttendanceState_IsValid(int value);
constexpr AttendanceState AttendanceState_MIN = ATTENDANCE_STATE_DEFAULT;
constexpr AttendanceState AttendanceState_MAX = LOGOUT;
constexpr int AttendanceState_ARRAYSIZE = AttendanceState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AttendanceState_descriptor();
template<typename T>
inline const std::string& AttendanceState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AttendanceState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AttendanceState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AttendanceState_descriptor(), enum_t_value);
}
inline bool AttendanceState_Parse(
    const std::string& name, AttendanceState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AttendanceState>(
    AttendanceState_descriptor(), name, value);
}
enum LogoutType : int {
  LOGOUT_TYPE_DEFAULT = 0,
  LT_NORMAL = 1,
  LT_FMS2TPA_HEART_TIME_OUT = 2,
  LT_TPA2FMS_HEART_TIME_OUT = 3,
  NETWORK_ERROR = 4,
  LogoutType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LogoutType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LogoutType_IsValid(int value);
constexpr LogoutType LogoutType_MIN = LOGOUT_TYPE_DEFAULT;
constexpr LogoutType LogoutType_MAX = NETWORK_ERROR;
constexpr int LogoutType_ARRAYSIZE = LogoutType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogoutType_descriptor();
template<typename T>
inline const std::string& LogoutType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogoutType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogoutType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogoutType_descriptor(), enum_t_value);
}
inline bool LogoutType_Parse(
    const std::string& name, LogoutType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogoutType>(
    LogoutType_descriptor(), name, value);
}
enum ArrivedStatusType : int {
  AT_DEFAULT = 0,
  AT_TZ = 1,
  AT_TP = 2,
  ALIGNED_UNLOCKED = 3,
  ALIGNED_LOCKED = 4,
  STOPPED = 5,
  ArrivedStatusType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ArrivedStatusType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ArrivedStatusType_IsValid(int value);
constexpr ArrivedStatusType ArrivedStatusType_MIN = AT_DEFAULT;
constexpr ArrivedStatusType ArrivedStatusType_MAX = STOPPED;
constexpr int ArrivedStatusType_ARRAYSIZE = ArrivedStatusType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArrivedStatusType_descriptor();
template<typename T>
inline const std::string& ArrivedStatusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArrivedStatusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArrivedStatusType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ArrivedStatusType_descriptor(), enum_t_value);
}
inline bool ArrivedStatusType_Parse(
    const std::string& name, ArrivedStatusType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ArrivedStatusType>(
    ArrivedStatusType_descriptor(), name, value);
}
enum InpositionType : int {
  IPT_DEFAULT = 0,
  LEAVE_SAFELY = 1,
  MAKE_LOCK = 2,
  MAKE_ALIGNMENT = 3,
  CPS_INVALID = 4,
  CRANE_UNSEATED = 5,
  InpositionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  InpositionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool InpositionType_IsValid(int value);
constexpr InpositionType InpositionType_MIN = IPT_DEFAULT;
constexpr InpositionType InpositionType_MAX = CRANE_UNSEATED;
constexpr int InpositionType_ARRAYSIZE = InpositionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InpositionType_descriptor();
template<typename T>
inline const std::string& InpositionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InpositionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InpositionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InpositionType_descriptor(), enum_t_value);
}
inline bool InpositionType_Parse(
    const std::string& name, InpositionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InpositionType>(
    InpositionType_descriptor(), name, value);
}
enum GuideType : int {
  GUIDE_TYPE_DEFAULT = 0,
  COLUMN = 1,
  GIRDER = 2,
  TAG = 3,
  GuideType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GuideType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GuideType_IsValid(int value);
constexpr GuideType GuideType_MIN = GUIDE_TYPE_DEFAULT;
constexpr GuideType GuideType_MAX = TAG;
constexpr int GuideType_ARRAYSIZE = GuideType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GuideType_descriptor();
template<typename T>
inline const std::string& GuideType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuideType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuideType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GuideType_descriptor(), enum_t_value);
}
inline bool GuideType_Parse(
    const std::string& name, GuideType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GuideType>(
    GuideType_descriptor(), name, value);
}
enum DestType : int {
  DEST_TYPE_DEFAULT = 0,
  YCTP = 1,
  PSTP = 2,
  PB = 3,
  PSTP_HPB = 4,
  PSTP_QPB = 5,
  QCTP = 6,
  QCTP_1 = 7,
  QCTP_2 = 8,
  QCTP_3 = 9,
  QCTP_4 = 10,
  QCTP_5 = 11,
  PCTP = 12,
  CHARGETP = 13,
  XRAYTP = 14,
  VPB = 15,
  DestType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DestType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DestType_IsValid(int value);
constexpr DestType DestType_MIN = DEST_TYPE_DEFAULT;
constexpr DestType DestType_MAX = VPB;
constexpr int DestType_ARRAYSIZE = DestType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DestType_descriptor();
template<typename T>
inline const std::string& DestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DestType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DestType_descriptor(), enum_t_value);
}
inline bool DestType_Parse(
    const std::string& name, DestType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DestType>(
    DestType_descriptor(), name, value);
}
enum WayPointsMode : int {
  WAYPOINT_MODE_DEFAULT = 0,
  WPM_NONE = 1,
  TRAJECTORY = 2,
  SECTION = 3,
  TURN_HAS_TRAJECTORY = 4,
  TURN_NO_TRAJECTORY = 5,
  OPEN_SPACE = 6,
  WayPointsMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WayPointsMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WayPointsMode_IsValid(int value);
constexpr WayPointsMode WayPointsMode_MIN = WAYPOINT_MODE_DEFAULT;
constexpr WayPointsMode WayPointsMode_MAX = OPEN_SPACE;
constexpr int WayPointsMode_ARRAYSIZE = WayPointsMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WayPointsMode_descriptor();
template<typename T>
inline const std::string& WayPointsMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WayPointsMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WayPointsMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WayPointsMode_descriptor(), enum_t_value);
}
inline bool WayPointsMode_Parse(
    const std::string& name, WayPointsMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WayPointsMode>(
    WayPointsMode_descriptor(), name, value);
}
enum SafeDistanceLevel : int {
  SAFE_DIS_LEVEL_DEFAULT = 0,
  FAR = 1,
  NEAR = 2,
  CLOSE = 3,
  IN_STATION = 4,
  SafeDistanceLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SafeDistanceLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SafeDistanceLevel_IsValid(int value);
constexpr SafeDistanceLevel SafeDistanceLevel_MIN = SAFE_DIS_LEVEL_DEFAULT;
constexpr SafeDistanceLevel SafeDistanceLevel_MAX = IN_STATION;
constexpr int SafeDistanceLevel_ARRAYSIZE = SafeDistanceLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SafeDistanceLevel_descriptor();
template<typename T>
inline const std::string& SafeDistanceLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SafeDistanceLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SafeDistanceLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SafeDistanceLevel_descriptor(), enum_t_value);
}
inline bool SafeDistanceLevel_Parse(
    const std::string& name, SafeDistanceLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SafeDistanceLevel>(
    SafeDistanceLevel_descriptor(), name, value);
}
enum PointType : int {
  POINT_TYPE_DEFAULT = 0,
  STRAIGHT = 1,
  TURN = 2,
  LANE_CHANGE_NORMAL = 3,
  LANE_CHANGE_ENTER_WORKING_LANE = 4,
  LANE_CHANGE_ENTER_STATION = 5,
  LANE_CHANGE_ENTER_CHARGE_LANE = 6,
  LANE_CHANGE_OUT_WORKING_LANE = 7,
  LANE_CHANGE_OUT_CHARGE_LANE = 8,
  PointType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PointType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PointType_IsValid(int value);
constexpr PointType PointType_MIN = POINT_TYPE_DEFAULT;
constexpr PointType PointType_MAX = LANE_CHANGE_OUT_CHARGE_LANE;
constexpr int PointType_ARRAYSIZE = PointType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PointType_descriptor();
template<typename T>
inline const std::string& PointType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PointType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PointType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PointType_descriptor(), enum_t_value);
}
inline bool PointType_Parse(
    const std::string& name, PointType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PointType>(
    PointType_descriptor(), name, value);
}
enum DriveDirection : int {
  DRIVE_DIRECTION_DEFAULT = 0,
  FORWARD = 1,
  BACKWARD = 2,
  DriveDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DriveDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DriveDirection_IsValid(int value);
constexpr DriveDirection DriveDirection_MIN = DRIVE_DIRECTION_DEFAULT;
constexpr DriveDirection DriveDirection_MAX = BACKWARD;
constexpr int DriveDirection_ARRAYSIZE = DriveDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DriveDirection_descriptor();
template<typename T>
inline const std::string& DriveDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DriveDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DriveDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DriveDirection_descriptor(), enum_t_value);
}
inline bool DriveDirection_Parse(
    const std::string& name, DriveDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DriveDirection>(
    DriveDirection_descriptor(), name, value);
}
enum ControlType : int {
  CONTROL_TYPE_DEFAULT = 0,
  PAUSE = 1,
  FINISH = 2,
  CANCEL = 3,
  ABORT = 4,
  RESUME = 5,
  LOCK = 6,
  UNLOCK = 7,
  SLOW_STOP = 8,
  ControlType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ControlType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ControlType_IsValid(int value);
constexpr ControlType ControlType_MIN = CONTROL_TYPE_DEFAULT;
constexpr ControlType ControlType_MAX = SLOW_STOP;
constexpr int ControlType_ARRAYSIZE = ControlType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ControlType_descriptor();
template<typename T>
inline const std::string& ControlType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ControlType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ControlType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ControlType_descriptor(), enum_t_value);
}
inline bool ControlType_Parse(
    const std::string& name, ControlType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ControlType>(
    ControlType_descriptor(), name, value);
}
enum LaneChangeType : int {
  LC_DEFAULT = 0,
  LEFT_LC = 1,
  RIGHT_LC = 2,
  LaneChangeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LaneChangeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LaneChangeType_IsValid(int value);
constexpr LaneChangeType LaneChangeType_MIN = LC_DEFAULT;
constexpr LaneChangeType LaneChangeType_MAX = RIGHT_LC;
constexpr int LaneChangeType_ARRAYSIZE = LaneChangeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaneChangeType_descriptor();
template<typename T>
inline const std::string& LaneChangeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LaneChangeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LaneChangeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LaneChangeType_descriptor(), enum_t_value);
}
inline bool LaneChangeType_Parse(
    const std::string& name, LaneChangeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LaneChangeType>(
    LaneChangeType_descriptor(), name, value);
}
enum DriveCmdType : int {
  DRIVE_CMD_TYPE_DEFAULT = 0,
  LEFT_BYPASS = 1,
  LEFT_LANE_CHANGE = 2,
  RIGHT_BYPASS = 3,
  RIGHT_LANE_CHANGE = 4,
  DriveCmdType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DriveCmdType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DriveCmdType_IsValid(int value);
constexpr DriveCmdType DriveCmdType_MIN = DRIVE_CMD_TYPE_DEFAULT;
constexpr DriveCmdType DriveCmdType_MAX = RIGHT_LANE_CHANGE;
constexpr int DriveCmdType_ARRAYSIZE = DriveCmdType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DriveCmdType_descriptor();
template<typename T>
inline const std::string& DriveCmdType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DriveCmdType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DriveCmdType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DriveCmdType_descriptor(), enum_t_value);
}
inline bool DriveCmdType_Parse(
    const std::string& name, DriveCmdType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DriveCmdType>(
    DriveCmdType_descriptor(), name, value);
}
enum PowerMgmtType : int {
  PMT_DEFAULT = 0,
  UP = 1,
  DOWN = 2,
  PowerMgmtType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PowerMgmtType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PowerMgmtType_IsValid(int value);
constexpr PowerMgmtType PowerMgmtType_MIN = PMT_DEFAULT;
constexpr PowerMgmtType PowerMgmtType_MAX = DOWN;
constexpr int PowerMgmtType_ARRAYSIZE = PowerMgmtType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PowerMgmtType_descriptor();
template<typename T>
inline const std::string& PowerMgmtType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PowerMgmtType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PowerMgmtType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PowerMgmtType_descriptor(), enum_t_value);
}
inline bool PowerMgmtType_Parse(
    const std::string& name, PowerMgmtType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PowerMgmtType>(
    PowerMgmtType_descriptor(), name, value);
}
enum ChargerType : int {
  CHARGER_TYPE_DEFAULT = 0,
  CHARGING = 1,
  CHARGE_COMPLETE = 2,
  CHARGE_FAIL = 3,
  ChargerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ChargerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ChargerType_IsValid(int value);
constexpr ChargerType ChargerType_MIN = CHARGER_TYPE_DEFAULT;
constexpr ChargerType ChargerType_MAX = CHARGE_FAIL;
constexpr int ChargerType_ARRAYSIZE = ChargerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChargerType_descriptor();
template<typename T>
inline const std::string& ChargerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChargerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChargerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChargerType_descriptor(), enum_t_value);
}
inline bool ChargerType_Parse(
    const std::string& name, ChargerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChargerType>(
    ChargerType_descriptor(), name, value);
}
enum BypassSequence : int {
  BYPASS_SEQUENCE_DEFAULT = 0,
  FREESTYLE = 1,
  SELECTIVE = 2,
  STRICT = 3,
  BypassSequence_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BypassSequence_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BypassSequence_IsValid(int value);
constexpr BypassSequence BypassSequence_MIN = BYPASS_SEQUENCE_DEFAULT;
constexpr BypassSequence BypassSequence_MAX = STRICT;
constexpr int BypassSequence_ARRAYSIZE = BypassSequence_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BypassSequence_descriptor();
template<typename T>
inline const std::string& BypassSequence_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BypassSequence>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BypassSequence_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BypassSequence_descriptor(), enum_t_value);
}
inline bool BypassSequence_Parse(
    const std::string& name, BypassSequence* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BypassSequence>(
    BypassSequence_descriptor(), name, value);
}
enum AreaStatus : int {
  AREA_STATUS_DEFAULT = 0,
  AREA_STATUS_CLOSED = 1,
  AREA_STATUS_IDLE = 2,
  AREA_STATUS_USED = 3,
  AreaStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AreaStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AreaStatus_IsValid(int value);
constexpr AreaStatus AreaStatus_MIN = AREA_STATUS_DEFAULT;
constexpr AreaStatus AreaStatus_MAX = AREA_STATUS_USED;
constexpr int AreaStatus_ARRAYSIZE = AreaStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AreaStatus_descriptor();
template<typename T>
inline const std::string& AreaStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AreaStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AreaStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AreaStatus_descriptor(), enum_t_value);
}
inline bool AreaStatus_Parse(
    const std::string& name, AreaStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AreaStatus>(
    AreaStatus_descriptor(), name, value);
}
enum PinsStatus : int {
  PINS_STATUS_DEFAULT = 0,
  PINS_STATUS_READY = 1,
  PINS_STATUS_AT_TZ = 2,
  PINS_STATUS_AT_TP = 3,
  PINS_STATUS_LOCK = 4,
  PINS_STATUS_UNLOCK = 5,
  PINS_STATUS_LEAVING = 6,
  PINS_STATUS_IDLE = 7,
  PinsStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PinsStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PinsStatus_IsValid(int value);
constexpr PinsStatus PinsStatus_MIN = PINS_STATUS_DEFAULT;
constexpr PinsStatus PinsStatus_MAX = PINS_STATUS_IDLE;
constexpr int PinsStatus_ARRAYSIZE = PinsStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PinsStatus_descriptor();
template<typename T>
inline const std::string& PinsStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PinsStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PinsStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PinsStatus_descriptor(), enum_t_value);
}
inline bool PinsStatus_Parse(
    const std::string& name, PinsStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PinsStatus>(
    PinsStatus_descriptor(), name, value);
}
enum ActType : int {
  ART = 0,
  TRUCK = 1,
  STACKER = 2,
  ActType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ActType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ActType_IsValid(int value);
constexpr ActType ActType_MIN = ART;
constexpr ActType ActType_MAX = STACKER;
constexpr int ActType_ARRAYSIZE = ActType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActType_descriptor();
template<typename T>
inline const std::string& ActType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActType_descriptor(), enum_t_value);
}
inline bool ActType_Parse(
    const std::string& name, ActType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActType>(
    ActType_descriptor(), name, value);
}
enum CraneType : int {
  QC = 0,
  YC = 1,
  DBYC = 2,
  CraneType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CraneType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CraneType_IsValid(int value);
constexpr CraneType CraneType_MIN = QC;
constexpr CraneType CraneType_MAX = DBYC;
constexpr int CraneType_ARRAYSIZE = CraneType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CraneType_descriptor();
template<typename T>
inline const std::string& CraneType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CraneType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CraneType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CraneType_descriptor(), enum_t_value);
}
inline bool CraneType_Parse(
    const std::string& name, CraneType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CraneType>(
    CraneType_descriptor(), name, value);
}
enum WorkState : int {
  WORK_STATE_DEFAULT = 0,
  WORK_IDLE = 1,
  WORK_WAIT_NAVI = 2,
  WORK_RUNNING = 3,
  WORK_ARRIVED = 4,
  WORK_ALIGNING = 5,
  WORK_LOCKED = 6,
  WorkState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WorkState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WorkState_IsValid(int value);
constexpr WorkState WorkState_MIN = WORK_STATE_DEFAULT;
constexpr WorkState WorkState_MAX = WORK_LOCKED;
constexpr int WorkState_ARRAYSIZE = WorkState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkState_descriptor();
template<typename T>
inline const std::string& WorkState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkState_descriptor(), enum_t_value);
}
inline bool WorkState_Parse(
    const std::string& name, WorkState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkState>(
    WorkState_descriptor(), name, value);
}
enum WaitPoint : int {
  WAIT_POINT_DEFAULT = 0,
  WAIT_POINT_FRONT = 1,
  WAIT_POINT_WORK = 2,
  WAIT_POINT_REAR = 3,
  WaitPoint_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WaitPoint_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WaitPoint_IsValid(int value);
constexpr WaitPoint WaitPoint_MIN = WAIT_POINT_DEFAULT;
constexpr WaitPoint WaitPoint_MAX = WAIT_POINT_REAR;
constexpr int WaitPoint_ARRAYSIZE = WaitPoint_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WaitPoint_descriptor();
template<typename T>
inline const std::string& WaitPoint_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WaitPoint>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WaitPoint_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WaitPoint_descriptor(), enum_t_value);
}
inline bool WaitPoint_Parse(
    const std::string& name, WaitPoint* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WaitPoint>(
    WaitPoint_descriptor(), name, value);
}
enum TwinFlag : int {
  TWIN_FLAG_DEFAULT = 0,
  TWIN_FLAG_BIND = 1,
  TWIN_FLAG_UNBIND = 2,
  ALONE_FLAG = 3,
  TwinFlag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TwinFlag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TwinFlag_IsValid(int value);
constexpr TwinFlag TwinFlag_MIN = TWIN_FLAG_DEFAULT;
constexpr TwinFlag TwinFlag_MAX = ALONE_FLAG;
constexpr int TwinFlag_ARRAYSIZE = TwinFlag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TwinFlag_descriptor();
template<typename T>
inline const std::string& TwinFlag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TwinFlag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TwinFlag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TwinFlag_descriptor(), enum_t_value);
}
inline bool TwinFlag_Parse(
    const std::string& name, TwinFlag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TwinFlag>(
    TwinFlag_descriptor(), name, value);
}
enum ConShow : int {
  CON_SHOW_DEFAULT = 0,
  CON_SHOW_FS = 1,
  CON_SHOW_RS = 2,
  CON_SHOW_MS = 3,
  CON_SHOW_MB = 4,
  CON_SHOW_TS = 5,
  ConShow_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ConShow_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ConShow_IsValid(int value);
constexpr ConShow ConShow_MIN = CON_SHOW_DEFAULT;
constexpr ConShow ConShow_MAX = CON_SHOW_TS;
constexpr int ConShow_ARRAYSIZE = ConShow_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConShow_descriptor();
template<typename T>
inline const std::string& ConShow_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConShow>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConShow_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConShow_descriptor(), enum_t_value);
}
inline bool ConShow_Parse(
    const std::string& name, ConShow* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConShow>(
    ConShow_descriptor(), name, value);
}
enum SpeedLevel : int {
  HIGH_SPEED = 0,
  MEDIUM_SPEED = 1,
  LOW_SPEED = 2,
  WIND_SPEED = 3,
  SpeedLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SpeedLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SpeedLevel_IsValid(int value);
constexpr SpeedLevel SpeedLevel_MIN = HIGH_SPEED;
constexpr SpeedLevel SpeedLevel_MAX = WIND_SPEED;
constexpr int SpeedLevel_ARRAYSIZE = SpeedLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpeedLevel_descriptor();
template<typename T>
inline const std::string& SpeedLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpeedLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpeedLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpeedLevel_descriptor(), enum_t_value);
}
inline bool SpeedLevel_Parse(
    const std::string& name, SpeedLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpeedLevel>(
    SpeedLevel_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace common

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::common::OrderStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::OrderStatus>() {
  return ::common::OrderStatus_descriptor();
}
template <> struct is_proto_enum< ::common::OrderType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::OrderType>() {
  return ::common::OrderType_descriptor();
}
template <> struct is_proto_enum< ::common::BusinessType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::BusinessType>() {
  return ::common::BusinessType_descriptor();
}
template <> struct is_proto_enum< ::common::TechnicalStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::TechnicalStatus>() {
  return ::common::TechnicalStatus_descriptor();
}
template <> struct is_proto_enum< ::common::MotionStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::MotionStatus>() {
  return ::common::MotionStatus_descriptor();
}
template <> struct is_proto_enum< ::common::WorkCycleDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::WorkCycleDirection>() {
  return ::common::WorkCycleDirection_descriptor();
}
template <> struct is_proto_enum< ::common::VesselDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::VesselDirection>() {
  return ::common::VesselDirection_descriptor();
}
template <> struct is_proto_enum< ::common::Gear> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::Gear>() {
  return ::common::Gear_descriptor();
}
template <> struct is_proto_enum< ::common::OperationalStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::OperationalStatus>() {
  return ::common::OperationalStatus_descriptor();
}
template <> struct is_proto_enum< ::common::TurnLight> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::TurnLight>() {
  return ::common::TurnLight_descriptor();
}
template <> struct is_proto_enum< ::common::StateFlow> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::StateFlow>() {
  return ::common::StateFlow_descriptor();
}
template <> struct is_proto_enum< ::common::ContainerPos> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::ContainerPos>() {
  return ::common::ContainerPos_descriptor();
}
template <> struct is_proto_enum< ::common::TaskType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::TaskType>() {
  return ::common::TaskType_descriptor();
}
template <> struct is_proto_enum< ::common::TaskMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::TaskMode>() {
  return ::common::TaskMode_descriptor();
}
template <> struct is_proto_enum< ::common::SteeringMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::SteeringMode>() {
  return ::common::SteeringMode_descriptor();
}
template <> struct is_proto_enum< ::common::AttendanceState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::AttendanceState>() {
  return ::common::AttendanceState_descriptor();
}
template <> struct is_proto_enum< ::common::LogoutType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::LogoutType>() {
  return ::common::LogoutType_descriptor();
}
template <> struct is_proto_enum< ::common::ArrivedStatusType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::ArrivedStatusType>() {
  return ::common::ArrivedStatusType_descriptor();
}
template <> struct is_proto_enum< ::common::InpositionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::InpositionType>() {
  return ::common::InpositionType_descriptor();
}
template <> struct is_proto_enum< ::common::GuideType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::GuideType>() {
  return ::common::GuideType_descriptor();
}
template <> struct is_proto_enum< ::common::DestType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::DestType>() {
  return ::common::DestType_descriptor();
}
template <> struct is_proto_enum< ::common::WayPointsMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::WayPointsMode>() {
  return ::common::WayPointsMode_descriptor();
}
template <> struct is_proto_enum< ::common::SafeDistanceLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::SafeDistanceLevel>() {
  return ::common::SafeDistanceLevel_descriptor();
}
template <> struct is_proto_enum< ::common::PointType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::PointType>() {
  return ::common::PointType_descriptor();
}
template <> struct is_proto_enum< ::common::DriveDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::DriveDirection>() {
  return ::common::DriveDirection_descriptor();
}
template <> struct is_proto_enum< ::common::ControlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::ControlType>() {
  return ::common::ControlType_descriptor();
}
template <> struct is_proto_enum< ::common::LaneChangeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::LaneChangeType>() {
  return ::common::LaneChangeType_descriptor();
}
template <> struct is_proto_enum< ::common::DriveCmdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::DriveCmdType>() {
  return ::common::DriveCmdType_descriptor();
}
template <> struct is_proto_enum< ::common::PowerMgmtType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::PowerMgmtType>() {
  return ::common::PowerMgmtType_descriptor();
}
template <> struct is_proto_enum< ::common::ChargerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::ChargerType>() {
  return ::common::ChargerType_descriptor();
}
template <> struct is_proto_enum< ::common::BypassSequence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::BypassSequence>() {
  return ::common::BypassSequence_descriptor();
}
template <> struct is_proto_enum< ::common::AreaStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::AreaStatus>() {
  return ::common::AreaStatus_descriptor();
}
template <> struct is_proto_enum< ::common::PinsStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::PinsStatus>() {
  return ::common::PinsStatus_descriptor();
}
template <> struct is_proto_enum< ::common::ActType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::ActType>() {
  return ::common::ActType_descriptor();
}
template <> struct is_proto_enum< ::common::CraneType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::CraneType>() {
  return ::common::CraneType_descriptor();
}
template <> struct is_proto_enum< ::common::WorkState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::WorkState>() {
  return ::common::WorkState_descriptor();
}
template <> struct is_proto_enum< ::common::WaitPoint> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::WaitPoint>() {
  return ::common::WaitPoint_descriptor();
}
template <> struct is_proto_enum< ::common::TwinFlag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::TwinFlag>() {
  return ::common::TwinFlag_descriptor();
}
template <> struct is_proto_enum< ::common::ConShow> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::ConShow>() {
  return ::common::ConShow_descriptor();
}
template <> struct is_proto_enum< ::common::SpeedLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::SpeedLevel>() {
  return ::common::SpeedLevel_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_common_2fenums_2eproto
